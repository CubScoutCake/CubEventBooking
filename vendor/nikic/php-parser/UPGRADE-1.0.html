<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
</head>
<body>
<h1 id="upgradingfromphp-parser0.9to1.0">Upgrading from PHP-Parser 0.9 to 1.0</h1>

<h3 id="phpversionrequirements">PHP version requirements</h3>

<p>PHP-Parser now requires PHP 5.3 or newer to run. It is however still possible to <em>parse</em> PHP 5.2 source code, while
running on a newer version.</p>

<h3 id="movetonamespacednames">Move to namespaced names</h3>

<p>The library has been moved to use namespaces with the <code>PhpParser</code> vendor prefix. However, the old names using
underscores are still available as aliases, as such most code should continue running on the new version without
further changes.</p>

<p>Old (still works, but discouraged):</p>

<pre><code class="php">$parser = new \PHPParser_Parser(new \PHPParser_Lexer_Emulative);
$prettyPrinter = new \PHPParser_PrettyPrinter_Default;
</code></pre>

<p>New:</p>

<pre><code class="php">$parser = new \PhpParser\Parser(new PhpParser\Lexer\Emulative);
$prettyPrinter = new \PhpParser\PrettyPrinter\Standard;
</code></pre>

<p>Note that the <code>PHPParser</code> prefix was changed to <code>PhpParser</code>. While PHP class names are technically case-insensitive,
the autoloader will not be able to load <code>PHPParser\Parser</code> or other case variants.</p>

<p>Due to conflicts with reserved keywords, some class names now end with an underscore, e.g. <code>PHPParser_Node_Stmt_Class</code>
is now <code>PhpParser\Node\Stmt\Class_</code>. (But as usual, the old name is still available.)</p>

<h3 id="changestonode::gettype">Changes to <code>Node::getType()</code></h3>

<p>The <code>Node::getType()</code> method continues to return names using underscores instead of namespace separators and also does
not contain the trailing underscore that may be present in the class name. As such its output will not change in many
cases.</p>

<p>However, some node classes have been moved to a different namespace or renamed, which will result in a different
<code>Node::getType()</code> output:</p>

<pre><code>Expr_AssignBitwiseAnd =&gt; Expr_AssignOp_BitwiseAnd
Expr_AssignBitwiseOr  =&gt; Expr_AssignOp_BitwiseOr
Expr_AssignBitwiseXor =&gt; Expr_AssignOp_BitwiseXor
Expr_AssignConcat     =&gt; Expr_AssignOp_Concat
Expr_AssignDiv        =&gt; Expr_AssignOp_Div
Expr_AssignMinus      =&gt; Expr_AssignOp_Minus
Expr_AssignMod        =&gt; Expr_AssignOp_Mod
Expr_AssignMul        =&gt; Expr_AssignOp_Mul
Expr_AssignPlus       =&gt; Expr_AssignOp_Plus
Expr_AssignShiftLeft  =&gt; Expr_AssignOp_ShiftLeft
Expr_AssignShiftRight =&gt; Expr_AssignOp_ShiftRight

Expr_BitwiseAnd       =&gt; Expr_BinaryOp_BitwiseAnd
Expr_BitwiseOr        =&gt; Expr_BinaryOp_BitwiseOr
Expr_BitwiseXor       =&gt; Expr_BinaryOp_BitwiseXor
Expr_BooleanAnd       =&gt; Expr_BinaryOp_BooleanAnd
Expr_BooleanOr        =&gt; Expr_BinaryOp_BooleanOr
Expr_Concat           =&gt; Expr_BinaryOp_Concat
Expr_Div              =&gt; Expr_BinaryOp_Div
Expr_Equal            =&gt; Expr_BinaryOp_Equal
Expr_Greater          =&gt; Expr_BinaryOp_Greater
Expr_GreaterOrEqual   =&gt; Expr_BinaryOp_GreaterOrEqual
Expr_Identical        =&gt; Expr_BinaryOp_Identical
Expr_LogicalAnd       =&gt; Expr_BinaryOp_LogicalAnd
Expr_LogicalOr        =&gt; Expr_BinaryOp_LogicalOr
Expr_LogicalXor       =&gt; Expr_BinaryOp_LogicalXor
Expr_Minus            =&gt; Expr_BinaryOp_Minus
Expr_Mod              =&gt; Expr_BinaryOp_Mod
Expr_Mul              =&gt; Expr_BinaryOp_Mul
Expr_NotEqual         =&gt; Expr_BinaryOp_NotEqual
Expr_NotIdentical     =&gt; Expr_BinaryOp_NotIdentical
Expr_Plus             =&gt; Expr_BinaryOp_Plus
Expr_ShiftLeft        =&gt; Expr_BinaryOp_ShiftLeft
Expr_ShiftRight       =&gt; Expr_BinaryOp_ShiftRight
Expr_Smaller          =&gt; Expr_BinaryOp_Smaller
Expr_SmallerOrEqual   =&gt; Expr_BinaryOp_SmallerOrEqual

Scalar_ClassConst     =&gt; Scalar_MagicConst_Class
Scalar_DirConst       =&gt; Scalar_MagicConst_Dir
Scalar_FileConst      =&gt; Scalar_MagicConst_File
Scalar_FuncConst      =&gt; Scalar_MagicConst_Function
Scalar_LineConst      =&gt; Scalar_MagicConst_Line
Scalar_MethodConst    =&gt; Scalar_MagicConst_Method
Scalar_NSConst        =&gt; Scalar_MagicConst_Namespace
Scalar_TraitConst     =&gt; Scalar_MagicConst_Trait
</code></pre>

<p>These changes may affect custom pretty printers and code comparing the return value of <code>Node::getType()</code> to specific
strings.</p>

<h3 id="miscellaneous">Miscellaneous</h3>

<ul>
<li><p>The classes <code>Template</code> and <code>TemplateLoader</code> have been removed. You should use some other <a href="https://github.com/nikic/PHP-Parser/wiki/Projects-using-the-PHP-Parser#code-generation">code generation</a>
project built on top of PHP-Parser instead.</p></li>
<li><p>The <code>PrettyPrinterAbstract::pStmts()</code> method now emits a leading newline if the statement list is not empty.
Custom pretty printers should remove the explicit newline before <code>pStmts()</code> calls.</p>

<p>Old:</p>

<pre><code class="php">public function pStmt_Trait(PHPParser_Node_Stmt_Trait $node) {
    return 'trait ' . $node-&gt;name
         . &quot;\n&quot; . '{' . &quot;\n&quot; . $this-&gt;pStmts($node-&gt;stmts) . &quot;\n&quot; . '}';
}
</code></pre>

<p>New:</p>

<pre><code class="php">public function pStmt_Trait(Stmt\Trait_ $node) {
    return 'trait ' . $node-&gt;name
         . &quot;\n&quot; . '{' . $this-&gt;pStmts($node-&gt;stmts) . &quot;\n&quot; . '}';
}
</code></pre></li>
</ul>

</body>
</html>
